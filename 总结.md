 中间件

```
mysql   43.138.11.85:3306  root    xdclass.net180
```

```
redis 60.204.187.97:6379   xdclass.net190
```

```
nacos
43.138.11.85
http://60.204.187.97:8848/nacos
```

```
miniIO
```



# 项目背景、意义

项目的意义就是做到一站式的测试平台，比如postman  jmeter selenimum

比如，jmeter用的时候很麻烦，输入，输出，本地，云服务器压测，

我们做的就是一个saas平台，通过浏览器访问，不用额外的安装，自动化测试平台，自研，安全，也可对外售卖使用

意义：

背景：

测试工具很多，没有统一的规范，每次测试要兼容语言、环境，重复测试，没有统一的基础设施规范，我们开发的就是这样的基础设施平台

，通过这个一站式的**测试平台、效能平台**。**生产测试报告**，提高效率，支持私有云、公有云部署，对内使用，对外售卖。

# 人员配比、周期

我是属于开发主程

6人小团队

3后端，2前端，测试1人

开发周期，初版3个月

# 接口文档

## 核心功能

接口自动化

​	替代接口测试，比如postman，但是更强大，多接口编排

UI自动化

​	替代界面测试，比如人工点击

压力测试

​	针对接口进行压测，比如jmeter

## 需求背景

项目上线需要测试的需求，然后招聘测试人员进行测试，利用postman、swagger，SeleniumUI自动化测试，jmeter压力测试，这些中间件还不通，质量也不同。通过招聘测试人员进行测试，带来问题就是人力成本过高，且混乱，效率低，没有统一的规范，也就会出现bug遗漏，测试人员不仅人力成本，而且从时间来说，也是很慢的，比如数据准备，或者说需求变动带来的新的测试需求，需要重新测试，浪费人力成本不说，效率还很低。

压测平台类似于Devlops的CICD这样,给运维团队使用，这个平台就是后端开发给测试人员使用，节约成本，提高效率。

主要几个问题：

**测试团队效率低，成本高**,与开发交付差。 

**本地测试、手工测试，自动化测试脚本不通用，测试工具繁杂，学习成本高**

**没有统一的测试报告文档**

**重复性工作多且技术简单**

**容易人工遗漏bug，**

**市面其他平台，有泄露数据风险。**

## 竞品分析

ApiFox

​	数据泄露风险，社区活跃度低

Meterphere

​	学习成本高，数据问题，高级功能付费

阿里云PTS 

​	缺点：付费，价格高，数据泄露问题

我们做：

​	最大的优势：可定制化，数据安全，既可对内部署使用，又可对外商用。

​	测开平台=postman+swagger+jmeter+Mock+seleuim

# 亮点总览

* 架构项目大课-自动化云测平台核心亮点（P3、P2、P1难度逐级上降）

  * P3（**提升技术广度-稳固基础设施**）

    - 云测平台**多账号登录体系**数据库**设计和编码实现**，支持手机-邮箱-社交账号
    - 最火的**轻量级权限认证框架SaToken**+整合AlibabaCloud微服务
    - **业务数据隔离控制**/项目空间/模块管理/接口管理+ **变更实时自动同步**
    - AlibabaCloud**微服务划分**/工程搭建/代码管理/**编码规范扫描**
    - **中间件一键部署**Kafka3.X/Redis7.X/Mysql8.X/MinIO/时序数据库/Prometheus等
    - **可视化实时监控+告警**，时序数据库InfluxDB+Grafana+**Prometheus**

    

  * P2（**技术驱动业务发展-难点攻克**）

    - 大厂项目管理中的**工时评估方法论**和**新领域项目风险把控技巧**
    - **源码封装StandardJMeterEngine自定义**压测引擎实战
    - 本地上传JMX结合压测引擎和**动态生成压测脚本**实战
    - **云端**压测**生成可视化压测报告**和**多文件打包压缩**下载实战
    - 自定义**在线**压测**聚合报告统计分析**和性能测试**报告在线分享**
    - 支持**HTTP多方法**测试**在线Web端接口测试**工具和**响应结果可视化**
    - 在线**API接口自动化测试**和可视化拖拽**多接口场景编排测试**
    - 数据驱动测试，支持**多文件格式参数导入读取**
    - **从0到1设计**公司自己的**自动化接口测试框架**和**可视化的断言**
    - **SpringBoot3.X二次封装Selenium**静默执行和**快照截图存储**
    - 支持丰富的**UI自动化测试报告**和多维度测试指标分析
    - **前后端分离架构**,基于**前端主流框架**+UI库+可视化图形报表 +**联调+前端部署上线**

    

  * P1（**架构综合能力-技术深度-核心板块攻坚**）

    - 掌握**架构分析方法论**，基于团队技术和业务需求**推断最合适的方案**
    - 滴云**自动化**压测**平台架构设计**和**多架构图分层绘制**
    - **新版SpringBoot3.X集成Jmeter5.X** 技术**多解决方案分析和业务选择**
    - SpringBoot3.X**二次封装Jmeter源码**实现**自定义**压测结果收集上报
    - 深入Jmeter压测链路+**java自定义创建测试计划/线程组/循环控制器/采样器**
    - **自定义ResultCollector整合Kafak实时收集数据和持久化存储**
    - 大型自动化**云测平台Mysql数据库模型设计**和SQL**索引优化实战**
    - 海量数据**存储技术选择**和数据库**执行计划分析+性能优化实战**
    - 自动化**多接口关联测试**和**上下文接口数据提取**实战
    - Selenium4.X **UI自动化测试引擎**整合**SpringBoot3.X封装**组件
    - 零代码或者**低代码整合Selenium 浏览器自动化测试**，高度可复用的测试脚本
    - Selenium **Web端**UI**自动化测试场景编排**，一键启动自动化测试
    - **技术Leader方法论**和团队管理技巧、**技术面试官成长法则**
    - 自动化云测平台**上线服务器资源评估**和**文件数据清理归档实战**
    - **DevOps自动化部署** Jenkins CICD + 阿里云Git仓库+ 阿里云ECS 服务器+ Docker容器编排调度
    - **技术组长或高级工程师简历编写和面试回答**



* 注意
  * 滴云自动化测试平台【**部分技术栈会调整变动**】，也是技术选型能力的提升
  * **遇到需求->想出多个解决方案->如何挑选->怎么判断是最适合的**

# 技术leader方法论

# 压力测试模块

## 痛点

二次封装jmeter，若不封装，将会有哪些问题

![image-20240106163723169](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401061637267.png)

1、**区分不同的环境，需要生产jmx脚本，修改参数，域名、端口，进入命令行压测,当很多接口的话，效率就会很低很低，**

2、**性能优化分析，报表，需要人工耗时计**

3、**项目迭代一下，还得重新压测，还要换个环境**,



* 本地Jmeter测试

* 图形化压测，直接GUI界面压测

* Linux服务器压测

  * 命令行压测，服务器需要安装JDK环境和JMeter安装包

  * 上传JMX压测脚本，如果有参数化文件还需要修改JMX脚本

  * 执行压测（进到Jmeter目录，测试报告目录需要先创建好）

    ```
    jmeter -n -t /usr/local/software/linux_load_test.jmx -l /usr/local/software/temp/jtl/result.jtl -e -o /usr/local/software/temp/result
    ```

    - -n 非gui方式运行jmeter
    - -t ：jmx 脚本路径
    - -l ：result.jtl 运行结果保存路径，注意：.jtl 文件名不能重复，文件夹需要存在
    - -e ：在脚本运行结束后生成 HTML 报告
    - -o ：用于存放 HTML 报告的目录，文件夹需要存在

    - 下载测试报告

* 最多的问题（项目工期紧张情况，如何高效完成压测）

  * 压测小项目几个接口容易，但是几十个上百个接口，不同环境下你如何提高速度。。。。
  * 测试报告查看对比麻烦，假如老王认真的对接口做了性能优化，又要进行压测一遍，且在不同环境

## SpringBoot如何整合Jmeter？

调用jmeter，包括从测试计划、执行、查看测试报告，做Saas领域，如何进行通讯？这是不同的进程

答案：

**Runtime运行类提供java运行时环境交互的方法，提供了操作系统的接口，使java程序能执行系统命令，访问系统资源并执行特定操作。**

但是，也很不变，顶多做个小脚本，也可以读日志，mq，消费，适合其他语言的

但是Jmeter是java语言编写的，不用这么麻烦，它提供了二次开发的相关命令！

## 数据库设计

**技术负责人完成三个需求，1怎么配置压测参数，开启压测和查看测试报告方便**

参数配置：

​	项目中就是**用例管理**，每个用例是一个压测需求，可以自己在ui配置，也可以传入jmx脚本

ER图

![image-20240106191601159](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401061916257.png)

8.17         3000

12.7      1000

3.23     2000

## 压测模块解决方案与总体架构设计

### 压测平台研发初期如何开始，技术解决方案的？

**比如二开Jmeter，看jmeter官方源码，市面竞品，比如阿里云PTS，再去搜索引擎、github上找一些类似的demo**

![image-20240116212025245](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401162120396.png)

### 二次开发小demo

```java
 @Test
    public void testJmeterScript() throws IOException {
        //Jmeter 路径
        String jmeterPath = "E:\\至尊笔记-李某人\\监控体系、链路压测\\jmeter压测工具\\apache-jmeter-5.4.1";
        //Jmeter根目录
        File jmeterHome = new File(jmeterPath);
        //JMX文件路径
        String jmxPath = "E:\\至尊笔记-李某人\\监控体系、链路压测\\jmeter压测工具\\脚本集合\\query.jmx";
        //JMX文件
        File jmxFile = new File(jmxPath);
        //Jmeter配置文件路径
        File jmeterProperties = new File(jmeterHome.getPath()+File.separator+"bin"+File.separator+"jmeter.properties");
        //设置Jmeter根目录
        JMeterUtils.setJMeterHome(jmeterHome.getPath());
        //加载jmeter配置文件
        JMeterUtils.loadJMeterProperties(jmeterProperties.getPath());

        //Jmeter标准引擎
        StandardJMeterEngine jmeter = new StandardJMeterEngine();
        //测试计划树
        HashTree testPlanTree = new HashTree();

        //设置文件服务器的基础脚本路径
        FileServer.getFileServer().setBaseForScript(jmxFile);
        //加载测试计划树 jmx脚本
        testPlanTree = SaveService.loadTree(jmxFile);

        //转换测试计划树
        JMeter.convertSubTree(testPlanTree,false);
        //Summariser对象
        Summariser summer = null;
        //Summariser名称
        String summaryName = JMeterUtils.getPropDefault("summariser.name", "summary");
        if (!summaryName.isEmpty()) {
            //创建Summariser对象
            summer = new Summariser(summaryName);
        }
        //结果日志文件名
        String logFile = "example.csv";
        //结果收集器
        ResultCollector logger = new ResultCollector(summer);
        logger.setFilename(logFile);
        //将结果收集器添加到测试计划树中
        testPlanTree.add(testPlanTree.getArray()[0],logger);
        //配置Jmeter引擎
        jmeter.configure(testPlanTree);
        //运行Jmeter测试
        jmeter.run();
    }
```

![image-20240117164251083](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401171642377.png)

### 压测引擎总体设计

![image-20240117174350451](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401171743596.png)

### 二次开发流程拆解

![image-20240119150457262](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191504560.png)

![image-20240119150846898](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191508953.png)

代码拆解

![](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191510446.png)

### 用例执行伪代码

![image-20240119155826488](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191558606.png)

### 压测结果处理

#### 问题描述

**测试的时候是将结果生成csv文件到execel表格，我们如何放松mq到data服务？**

**答案：自定义结果收集器**

**核心：继承ResultCollector，重写里面的回调方法，然后封装成对象发送到mq，data服务消费。**

![image-20240121181530824](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401211815928.png)

![image-20240121181543079](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401211815129.png)

其实就是重写之后把结果回调到这里，我们在这里发送给mq到data服务接受就好了。

注意：![image-20240121195223014](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401211952073.png)

**Map是因为同一个线程组，同一个jmx文件里面可能有多个压测请求**

![image-20240121195530111](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401211955161.png)

#### 小demo

```java
@Slf4j
public class TestResultCollector extends ResultCollector {

    

    public TestResultCollector() {
        super();
    }

    public TestResultCollector(Summariser summer) {
        super(summer);
    }

    @Override
    public void sampleOccurred(SampleEvent event) {
        super.sampleOccurred(event);
        System.out.println("label=" + event.getResult().getSampleLabel());
        System.out.println("getRequestHeaders=" + event.getResult().getRequestHeaders());
        System.out.println("getResponseHeaders=" + event.getResult().getResponseHeaders());
        System.out.println("ThreadGroup=" + event.getThreadGroup());
        System.out.println("ResponseCode=" + event.getResult().getResponseCode());
        System.out.println("Hostname" + event.getHostname());
        System.out.println("getResponseDataAsString=" + event.getResult().getResponseDataAsString());

        AssertionResult[] assertionResults = event.getResult().getAssertionResults();
        for(AssertionResult assertionResult : assertionResults){
            System.out.println("AssertionResult="+assertionResult.getName()+",FailureMessage="+assertionResult.getFailureMessage());
        }
    }
}

```

#### 开发

统计数据类SampingStaCalculator

![image-20240121222746795](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401212227999.png)

#### 接口封装mq，支持替换（亮点）

```
封装接口，
redis kafka  rabbitMq，方便后续替换
```

### 压测用例来源设计-模板方法（亮点）

![image-20240122114352576](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401221143984.png)

### 可变参数

可变参数，csv，因为参数并不能简单的压测一个，比如查询接口就可能会

![image-20240127102238108](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271022093.png)

![image-20240127103735365](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271037516.png)

![image-20240127102322573](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271023635.png)



#### 可变参数设计问题与解决架构

##### 问题

![image-20240127111423378](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271114501.png)

##### 解决



![image-20240127132905653](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271329794.png)

![image-20240127133352681](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271333805.png)

![image-20240127134751088](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401271347189.png)

# 滴总笔记截图

## 7章

### 5集

![image-20240117193430625](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401171934791.png)

## 8章

### 1集

![image-20240119150917217](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191509357.png)

![image-20240119151005335](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191510446.png)

### 2集

![image-20240119151959001](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191519136.png)

### 3集 用例执行伪代码

![image-20240119155759553](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191557680.png)

### 4集数据服务初始化压测报告接口

![image-20240119193854000](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401191938101.png)

## 9章

### 1集

![image-20240120193745497](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401201937695.png)

### 3集

![image-20240120215405432](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401202154545.png)

## 10章

### 1集

![image-20240121181059176](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401211810500.png)

![image-20240121194559787](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401211945929.png)

### 2集 开发收集器

![image-20240121202955656](https://lhc-blog-use.oss-cn-beijing.aliyuncs.com/blog/2023202401212029793.png)